package service

import (
	"context"
	"encoding/base64"
	"errors"
	"time"

	"github.com/4epyx/testtask/model"
	"github.com/4epyx/testtask/repository"
	"github.com/4epyx/testtask/util"
	"github.com/golang-jwt/jwt"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// TokenService may be used for work with tokens (get pair of tokens or update tokens)
type TokenService struct {
	// repo is an instance of refresh token repository
	repo repository.RefreshTokenRepository
	// accessTokenTTL is a time to live  of access token
	accessTokenTTL time.Duration
	// refershTokenTTL is a time to live of refresh token
	refreshTokenTTL time.Duration
	// accessJwtSecretKey is a secret string, which access token will sign
	accessJwtSecretKey []byte
	// refreshJwtSecretKey is a secret string, which refresh token will sign
	refreshJwtSecretKey []byte
}

// NewTokenService creates a new instance of token service
func NewTokenService(repo repository.RefreshTokenRepository, accessTokenTTL, refreshTokenTTL time.Duration, accessJwtSecret, refershJwtSecret []byte) *TokenService {
	return &TokenService{
		repo:                repo,
		accessTokenTTL:      accessTokenTTL,
		refreshTokenTTL:     refreshTokenTTL,
		accessJwtSecretKey:  accessJwtSecret,
		refreshJwtSecretKey: refershJwtSecret,
	}
}

// GenerateAccessToken returns access token, generated by their GUID or error if something goes wrong
func (s *TokenService) GenerateAccessToken(ctx context.Context, userGuid string) (string, error) {
	claims := jwt.MapClaims{
		"user_guid": userGuid,
		"exp":       time.Now().Add(s.accessTokenTTL).Unix(),
	}

	accessToken, err := s.generateJwt(claims, jwt.SigningMethodHS512, s.accessJwtSecretKey)
	if err != nil {
		return "", err
	}

	return accessToken, nil
}

// GenerateRefreshToken returns refresh token, generated by their GUID or error if something goes wrong
func (s *TokenService) GenerateRefreshToken(ctx context.Context, userGuid string) (string, error) {
	tokenUuid := uuid.NewString()
	tokenExpiration := time.Now().Add(s.refreshTokenTTL).Unix()

	claims := jwt.MapClaims{
		"id":        tokenUuid,
		"user_guid": userGuid,
		"exp":       tokenExpiration,
	}

	jwtToken, err := s.generateJwt(claims, jwt.SigningMethodHS512, s.refreshJwtSecretKey)
	if err != nil {
		return "", err
	}

	// encode the token to base64
	encoded := base64.StdEncoding.EncodeToString([]byte(jwtToken))

	// hash the token for storage in the database
	hash, err := bcrypt.GenerateFromPassword([]byte(encoded), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}

	tokenData := model.RefreshToken{
		Id:         tokenUuid,
		UserGuid:   userGuid,
		Expiration: tokenExpiration,
		Token:      string(hash),
	}
	if err := s.repo.CreateToken(ctx, tokenData); err != nil {
		return "", err
	}

	return encoded, nil
}

// RefreshToken accept refresh token and returns new pair of tokens (access and refresh) or error if something goes wrong
func (s *TokenService) RefreshToken(ctx context.Context, refreshToken string) (util.Tokens, error) {
	// decode base64 representation of the refresh JWT
	decoded, err := base64.StdEncoding.DecodeString(refreshToken)
	if err != nil {
		return util.Tokens{}, err
	}

	// get data form refresh token
	claims, err := s.getJwtClaims(string(decoded), s.refreshJwtSecretKey)
	if err != nil {
		return util.Tokens{}, err
	}

	// get UUID of the token
	id, ok := claims["id"]
	if !ok {
		return util.Tokens{}, errors.New("invalid refresh token")
	}

	token, err := s.repo.GetTokenById(ctx, id.(string))
	if err != nil {
		return util.Tokens{}, err
	}

	// compare hash of token from the database and token from parameters
	if err := bcrypt.CompareHashAndPassword([]byte(token.Token), []byte(refreshToken)); err != nil {
		return util.Tokens{}, err
	}

	newAccessToken, err := s.GenerateAccessToken(ctx, token.UserGuid)
	if err != nil {
		return util.Tokens{}, err
	}

	newRefreshToken, err := s.GenerateRefreshToken(ctx, token.UserGuid)
	if err != nil {
		return util.Tokens{}, err
	}

	// delete used refresh token from the database to avoid reuse
	if err := s.repo.DeleteToken(ctx, token.Id); err != nil {
		return util.Tokens{}, err
	}

	return util.Tokens{
		AccessToken:  newAccessToken,
		RefreshToken: newRefreshToken,
	}, nil
}

// generateJwt returns new JWT, generated with claims, signed with the given method and key
func (s *TokenService) generateJwt(claims jwt.MapClaims, method jwt.SigningMethod, key []byte) (string, error) {
	token := jwt.NewWithClaims(method, claims)
	return token.SignedString(key)
}

// getJwtClaims returns claims from the given JWT, signed with the given key
func (s *TokenService) getJwtClaims(token string, key []byte) (jwt.MapClaims, error) {
	claims := jwt.MapClaims{}
	_, err := jwt.ParseWithClaims(token, claims, func(t *jwt.Token) (interface{}, error) {
		return s.refreshJwtSecretKey, nil
	})

	return claims, err
}
